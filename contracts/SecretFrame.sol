// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import {FHE, eaddress, externalEaddress} from "@fhevm/solidity/lib/FHE.sol";
import {ZamaEthereumConfig} from "@fhevm/solidity/config/ZamaConfig.sol";

/// @title SecretFrame - Encrypted URL Soulbound ERC721
/// @notice Each NFT stores an encrypted URL and an encrypted viewer address that only the owner can decrypt.
contract SecretFrame is ZamaEthereumConfig {
    string public constant name = "SecretFrame";
    string public constant symbol = "SF";

    struct FrameData {
        string encryptedUrl;
        eaddress encryptedViewerKey;
        uint256 mintedAt;
    }

    struct FrameView {
        uint256 tokenId;
        string encryptedUrl;
        eaddress encryptedViewerKey;
        uint256 mintedAt;
        address owner;
    }

    uint256 private _nextTokenId = 1;

    mapping(uint256 => address) private _owners;
    mapping(address => uint256) private _balances;
    mapping(address => uint256[]) private _ownedTokens;
    mapping(uint256 => FrameData) private _frames;

    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);
    event Approval(address indexed owner, address indexed spender, uint256 indexed tokenId);
    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);
    event FrameMinted(address indexed owner, uint256 indexed tokenId, string encryptedUrl);

    error TransferDisabled();
    error InvalidReceiver();
    error TokenDoesNotExist();

    modifier exists(uint256 tokenId) {
        if (_owners[tokenId] == address(0)) {
            revert TokenDoesNotExist();
        }
        _;
    }

    /// @notice Mint a new SecretFrame NFT with encrypted payloads.
    /// @param encryptedUrl URL encrypted off-chain with a random address key.
    /// @param encryptedViewerKey Random address key encrypted for the contract using FHE.
    /// @param inputProof Input proof generated by the relayer SDK.
    /// @return tokenId Newly minted token id.
    function mintFrame(string calldata encryptedUrl, externalEaddress encryptedViewerKey, bytes calldata inputProof)
        external
        returns (uint256 tokenId)
    {
        require(bytes(encryptedUrl).length > 0, "Encrypted url required");

        eaddress viewerKey = FHE.fromExternal(encryptedViewerKey, inputProof);

        tokenId = _nextTokenId++;
        _owners[tokenId] = msg.sender;
        _balances[msg.sender] += 1;
        _ownedTokens[msg.sender].push(tokenId);

        _frames[tokenId] = FrameData({encryptedUrl: encryptedUrl, encryptedViewerKey: viewerKey, mintedAt: block.timestamp});

        FHE.allowThis(viewerKey);
        FHE.allow(viewerKey, msg.sender);

        emit Transfer(address(0), msg.sender, tokenId);
        emit FrameMinted(msg.sender, tokenId, encryptedUrl);
    }

    /// @notice Soulbound token transfer disabled.
    function transferFrom(address, address, uint256) public pure {
        revert TransferDisabled();
    }

    /// @notice Soulbound token transfer disabled.
    function safeTransferFrom(address, address, uint256) external pure {
        revert TransferDisabled();
    }

    /// @notice Soulbound token transfer disabled.
    function safeTransferFrom(address, address, uint256, bytes calldata) external pure {
        revert TransferDisabled();
    }

    /// @notice Approvals are disabled because transfers are blocked.
    function approve(address, uint256) external pure {
        revert TransferDisabled();
    }

    /// @notice Approvals are disabled because transfers are blocked.
    function setApprovalForAll(address, bool) external pure {
        revert TransferDisabled();
    }

    /// @notice Always returns false because approvals are disabled.
    function isApprovedForAll(address, address) external pure returns (bool) {
        return false;
    }

    /// @notice Always returns the zero address because approvals are disabled.
    function getApproved(uint256) external pure returns (address) {
        return address(0);
    }

    /// @notice Fetch encrypted data for a single token id.
    /// @param tokenId Token id to query.
    /// @return encryptedUrl Encrypted URL string.
    /// @return encryptedViewerKey Encrypted address key handle.
    /// @return mintedAt Timestamp when the token was minted.
    function getFrame(uint256 tokenId)
        external
        view
        exists(tokenId)
        returns (string memory encryptedUrl, eaddress encryptedViewerKey, uint256 mintedAt)
    {
        FrameData storage data = _frames[tokenId];
        return (data.encryptedUrl, data.encryptedViewerKey, data.mintedAt);
    }

    /// @notice Retrieve all frame data owned by a specific address.
    function framesOf(address owner) external view returns (FrameView[] memory frames) {
        uint256[] storage tokenIds = _ownedTokens[owner];
        frames = new FrameView[](tokenIds.length);
        for (uint256 i = 0; i < tokenIds.length; i++) {
            uint256 tokenId = tokenIds[i];
            FrameData storage data = _frames[tokenId];
            frames[i] = FrameView({
                tokenId: tokenId,
                encryptedUrl: data.encryptedUrl,
                encryptedViewerKey: data.encryptedViewerKey,
                mintedAt: data.mintedAt,
                owner: owner
            });
        }
    }

    /// @notice Enumerate token ids owned by an address.
    function tokensOf(address owner) external view returns (uint256[] memory) {
        return _ownedTokens[owner];
    }

    /// @notice ERC165 support.
    function supportsInterface(bytes4 interfaceId) external pure returns (bool) {
        return interfaceId == 0x80ac58cd || interfaceId == 0x01ffc9a7;
    }

    /// @notice Get the balance of an owner.
    function balanceOf(address owner) public view returns (uint256) {
        require(owner != address(0), "Zero address");
        return _balances[owner];
    }

    /// @notice Get the owner of a token.
    function ownerOf(uint256 tokenId) public view exists(tokenId) returns (address) {
        return _owners[tokenId];
    }
}
